
This notebook runs through the code required to produce figure 3. 

First, we generate simulated data. 

```{r, warning=FALSE, message=FALSE}
library(MASS)
library(Matrix)
library(reshape2)
library(ggplot2)
library(ggthemes)
library(cowplot)
library(glmmTMB)
library(scales)
library(viridis)
library(tidyr)
library(pbkrtest)
library(lmerTest)
library(edgeR)
library(miloR)
```

```{r}
initializeFullZsim <- function(Z, cluster_levels, stand.cols=FALSE){
    # construct the full Z with all random effect levels
    n.cols <- ncol(Z)
    col.classes <- apply(Z, 2, class)
    i.z.list <- list()
    for(i in seq_len(n.cols)){
        i.class <- col.classes[i]
        if(i.class %in% c("factor")){ # treat as factors
            i.levels <- levels(Z[, i, drop=FALSE])
            i.levels <- as.factor(paste(sort(as.integer(i.levels))))
            i.z <- sapply(i.levels, FUN=function(X) (Z[, i] == X) + 0, simplify=TRUE)
        } else if(i.class %in% c("character")){
            i.levels <- unique(Z[, i, drop=FALSE])
            i.levels <- as.factor(paste(sort(as.integer(i.levels))))
            i.z <- sapply(i.levels, FUN=function(X) (Z[, i] == X) + 0, simplify=TRUE)
        } else if(i.class %in% c("numeric")){ # split into unique levels if integer levels
            i.mod <- all(Z[, i, drop=FALSE] %% 1 == 0)
            if(isTRUE(i.mod)){
                i.levels <- unique(Z[, i])
                i.levels <- as.factor(paste(sort(as.integer(i.levels))))
                i.z <- sapply(i.levels, FUN=function(X) (Z[, i] == X) + 0, simplify=TRUE)
            } else{
                i.z <- Z[, i, drop=FALSE] # if float then treat as continuous
            }
        } else if(i.class %in% c("integer")){
            i.levels <- (unique(Z[, i]))
            i.levels <- as.factor(paste(sort(as.integer(i.levels))))
            i.z <- sapply(i.levels, FUN=function(X) (Z[, i] == X) + 0, simplify=TRUE)
        }
        colnames(i.z) <- cluster_levels[[colnames(Z)[i]]]
        
        # to standardise or not?
        if(isTRUE(stand.cols)){
            q <- ncol(i.z)
            i.ident <- diag(1L, nrow=nrow(i.z), ncol=nrow(i.z))
            i.star <- i.z - ((i.ident %*% i.z)/q)
            i.z <- i.star
        }
        
        i.z.list[[colnames(Z)[i]]] <- i.z
    }
    full.Z <- do.call(cbind, i.z.list)
    return(full.Z)
}
```


```{r}
SimulateXZ <- function(N, n.fe, n.re, re.levels, fe.levels){
    
    # create a per-level mean effect for each FE
    if(length(fe.levels) != n.fe){
        stop("List entries need to match number of input fixed effects")
    }
    
    if(length(re.levels) != n.re){
        stop("List entries need to match number of input random effects")
    }
    
    # create the design matrices
    X <- matrix(0L, ncol=n.fe+1, nrow=N)
    X[, 1] <- 1
    colnames(X) <- c("Intercept", names(fe.levels))
    
    Z <- matrix(0L, ncol=n.re, nrow=N)
    
    for(i in seq_len(n.fe)){
        if(fe.levels[[i]] == 1){
            X[, i+1] <- sapply(seq_len(N), FUN=function(B){
                rnorm(1, mean=0, sd=1)
                })
        } else if(fe.levels[[i]] == 2){
            X[, i+1] <- sapply(seq_len(N), FUN=function(B){
                sample(c(0, 1), 1)
                })
            X[, i+1] <- as.factor(X[, i+1])
        }else{
            X[, i+1] <- sapply(seq_len(N), FUN=function(B){
                sample(seq_len(fe.levels[[i]]), 1)
                })
            X[, i+1] <- as.factor(X[, i+1])
        }
    }
    
    # Make categorical effects 0 or 1 (not 1 or 2)
    X[,2] <- X[,2] - 1
    
    for(j in seq_len(n.re)){
        if(re.levels[[j]] == 1){
            Z[, j] <- sapply(seq_len, FUN=function(R){
                rnorm(1, mean=1, sd=1)
            })
        } else{
            Z[, j] <- sapply(seq_len(N), FUN=function(R){
                sample(seq_len(re.levels[[j]]), 1)
            })
            Z[, j] <- factor(Z[, j], levels=c(1:re.levels[[j]]))
        }
    }
    colnames(Z) <- names(re.levels)

    sim.data <- do.call(cbind.data.frame, list(X, Z))
    return(sim.data)
}


SimulateY <- function(N, X, Z, fe.betas, re.sigmas,
                           dispersion, grand.mean, n.fe, n.re,
                           re.levels,
                           fe.levels){
    
    # create a per-level mean effect for each FE
    if(length(fe.levels) != n.fe){
        stop("List entries need to match number of input fixed effects")
    }
    
    if(length(re.levels) != n.re){
        stop("List entries need to match number of input random effects")
    }
    
    # construct the full Z
    random.levels <- sapply(seq_len(length(re.levels)), FUN=function(RX) {
        rx.name <- names(re.levels)[RX]
        paste(rx.name, seq_len(re.levels[[rx.name]]), sep="_")
        }, simplify=FALSE)
    names(random.levels) <- names(re.levels)

    full.Z <- initializeFullZsim(Z, random.levels)
    
    # get a combination over random effects 
    # and sample each level from the same ~Normal(0, sigma)
    # note that the variance would be G if we also had random slopes
    re.thetas <- list()
    for(i in seq_len(length(re.levels))){
        i.re <- names(random.levels[i])
        i.levels <- length(random.levels[[i.re]])
        i.re.means <- rnorm(n=i.levels, 0, sd=sqrt(re.sigmas[[i.re]])) # sample a random effect value
        i.re.list <- sapply(seq_len(i.levels), FUN=function(X) i.re.means[X])
        names(i.re.list) <- random.levels[[i.re]]
        re.thetas[[i.re]] <- i.re.list
    }
    
    B <- full.Z %*% unlist(re.thetas)
    # map the fixed effects to mean values
    betas <- c(grand.mean, unlist(fe.betas))
    Beta <- X %*% betas

    i.error <- matrix(data = rnorm(N, mean=0, sd=0.001), ncol = 1)
    
    # construct the y.means equation, depending on desired distribution and FE/RE
    y.means <- exp(Beta + B) 
    y.means <- y.means + i.error
    
    y.counts <- rnbinom(N, mu = y.means, size = dispersion)

    sim.data <- data.frame("Mean.Count"=y.counts)
    sim.data <- do.call(cbind.data.frame, list(sim.data, X, Z))

    return(sim.data)
}
```

Create a simulation with known parameter values to benchmark the accuracy of the glmm model and compare REML to non-REML.

```{r, warning=FALSE, message=FALSE}
N=1000
fe.levels <- list("FE1"=2)
re.levels <- list("RE1"=10)
set.seed(43)
design.sim <- SimulateXZ(N=N, n.fe=length(fe.levels), n.re=length(re.levels), re.levels=re.levels, fe.levels=fe.levels)
j <- 1
sim.list <- c()

for (i in seq(0.0, 0.2, 0.05)){
    set.seed(43)
    r.dispersion <- 0.5
    fe.betas=list("FE1"=0.25)
    re.sigmas=list("RE1"=i)
    grand.mean=2
    sim.list[[j]] <- SimulateY(N=N, X=sapply(design.sim[,1:2], as.numeric), Z=design.sim[,3,drop=FALSE],
                        fe.betas=fe.betas, re.sigmas=re.sigmas, dispersion=r.dispersion,
                        grand.mean=grand.mean, n.fe=length(fe.betas), n.re=length(re.sigmas),
                        re.levels=re.levels, fe.levels=fe.levels)
    j <- j + 1

}
names(sim.list) <- seq(0.0, 0.2, 0.05)

glmmWrapper <- function(sim.df){
    z.model <- sapply(sim.df[,4, drop = FALSE], as.numeric)
    x.model <- sapply(sim.df[,2:3], as.numeric)
    y.model <- sapply(sim.df[,1, drop=FALSE], as.numeric)
    rand.levels <- lapply(seq_along(colnames(z.model)), FUN=function(X) unique(z.model[, X]))
    names(rand.levels) <- colnames(z.model)

    model.list <- runGLMM(X=x.model, Z=z.model, y=y.model, random.levels=rand.levels, REML = FALSE, 
                    dispersion=r.dispersion, glmm.control=list(theta.tol=1e-6, max.iter=20))

    out.list <- list("coefficients"=c(model.list$FE, model.list$RE),
                         "sigma"=model.list$Sigma)
}
glmm.sim.list <- lapply(sim.list, glmmWrapper)

glmmWrapperREML <- function(sim.df){
    z.model <- sapply(sim.df[,4, drop = FALSE], as.numeric)
    x.model <- sapply(sim.df[,2:3], as.numeric)
    y.model <- sapply(sim.df[,1, drop=FALSE], as.numeric)
    rand.levels <- lapply(seq_along(colnames(z.model)), FUN=function(X) unique(z.model[, X]))
    names(rand.levels) <- colnames(z.model)

    model.list <- runGLMM(X=x.model, Z=z.model, y=y.model, random.levels=rand.levels, REML = TRUE, 
                    dispersion=r.dispersion, glmm.control=list(theta.tol=1e-6, max.iter=20))

    out.list <- list("coefficients"=c(model.list$FE, model.list$RE),
                         "sigma"=model.list$Sigma)
}
glmm.sim.listREML <- lapply(sim.list, glmmWrapperREML)

# glmm.tmb <- glmmTMB(Mean.Count ~ FE1 + (1|RE1), sim.list[[1]], family=nbinom2(link="log"), REML = TRUE)
# summary(glmm.tmb)

coeff <- lapply(glmm.sim.list, `[[`, 1)
sigma <- lapply(glmm.sim.list, `[[`, 2)
coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=12)))[,1:2]
coeff_mat <- data.frame(cbind(unlist(sigma), coeff_mat))
coeff_mat$ground_truth <- as.numeric(rownames(coeff_mat))
colnames(coeff_mat) <- c("sigma", "se.int", "se.fe", "ground_truth")
coeff_mat$analysis <- "nb_glmm"
coeff_pivoted <- pivot_longer(coeff_mat, cols = 1:3)

coeff <- lapply(glmm.sim.listREML, `[[`, 1)
sigma <- lapply(glmm.sim.listREML, `[[`, 2)
coeff_mat <- t(data.frame(matrix(unlist(coeff), nrow=12)))[,1:2]
coeff_mat <- data.frame(cbind(unlist(sigma), coeff_mat))
coeff_mat$ground_truth <- as.numeric(rownames(coeff_mat))
colnames(coeff_mat) <- c("sigma", "se.int", "se.fe", "ground_truth")
coeff_mat$analysis <- "nb_glmm_REML"
coeff_pivoted2 <- pivot_longer(coeff_mat, cols = 1:3)

to_plot <- rbind.data.frame(coeff_pivoted, coeff_pivoted2)
to_plot_f <- dplyr::filter(to_plot, name =="sigma")

ggplot(to_plot_f, aes(y = value, x = as.factor(ground_truth), group = analysis)) +
    geom_bar(stat = "identity", color = "black", position = position_dodge(), aes(fill=analysis)) +
    theme_bw() +
    xlab("Ground truth variance") +
    ylab("Estimated variance") +
    theme(legend.position = "none", axis.text.x=element_text(colour="black"), axis.text.y=element_text(colour="black")) +
    theme(text = element_text(size = 18)) +
    scale_y_continuous(limits = c(0, 0.15), breaks = seq(0.0, 0.2, 0.05), expand = c(0,0)) +
    scale_fill_manual(values = c("#F4D1E9", "#8da0cb"), name="Model", labels = c("Non-REML", "REML"))
#geom_abline(intercept = 0, slope = 0.05)
```


We can specify the number of nhoods as well as the number of individuals (sample size).
Here we are running the model with one fixed and one random effect. 
We simulate real data by allowing the betas (intercept and coefficient), the dispersion (r) and the sigmas to vary between neighborhoods.

```{r, warning=FALSE, message=FALSE}

N=500
fe.levels <- list("FE1"=2)
re.levels <- list("RE1"=10)
design.sim <- SimulateXZ(N=N, n.fe=length(fe.levels), n.re=length(re.levels), re.levels=re.levels, fe.levels=fe.levels)

n <- 100 # number of neighborhoods
sim.list <- c()

for (i in 1:n) {
    r.dispersion <- runif(1, min = 2, max = 2.5)
    fe.betas=list("FE1"=runif(1, min = 0.15, max = 0.25))
    re.sigmas=list("RE1"=runif(1, min = 0.05, max = 0.1))
    grand.mean=runif(1, min = 1, max = 2)
    sim.list[[i]]  <- SimulateY(N=N, X=sapply(design.sim[,1:2], as.numeric), Z=design.sim[,3, drop=FALSE], fe.betas=fe.betas, re.sigmas=re.sigmas, dispersion=r.dispersion, grand.mean=grand.mean, n.fe=length(fe.betas), n.re=length(re.sigmas), re.levels=re.levels, fe.levels=fe.levels)
}

names(sim.list) <- 1:n

# extract the y values ie. the neighborhood counts
y <- lapply(sim.list, `[[`, 1)
y_matrix <- matrix(unlist(y), nrow = N, ncol = n)
colnames(y_matrix) <- paste("n", 1:n, sep = "_")
```

Create a simulation-based milo object and input the y_matrix instead of the nhoodCounts slot.

```{r}
data(sim_trajectory)
milo.meta <- sim_trajectory$meta
milo.obj <- Milo(sim_trajectory$SCE)
milo.obj <- buildGraph(milo.obj, k=20, d=30)
#milo.obj <- makeNhoods(milo.obj, k=20, d=30, refined=TRUE, prop=0.2)

milo.obj@nhoodIndex <- as.list(1:n)

y_counts <- Matrix(t(y_matrix), sparse = T)
rownames(y_counts) <- 1:nrow(y_counts)
colnames(y_counts) <- 1:ncol(y_counts)
milo.obj@nhoodCounts <- y_counts 

X <- sapply(design.sim[,2, drop = F], as.numeric)
Z <- design.sim[,3, drop = F]
design.df <- cbind(X, Z)
colnames(design.df) <- c("ConditionB", "RE")
rownames(design.df) <- 1:nrow(design.df)
x <- milo.obj
milo.res <- testNhoods(milo.obj, design= ~ConditionB + (1|RE), design.df=design.df)
milo.res.fixed <- testNhoods(milo.obj, design= ~ConditionB, design.df=design.df)
```

```{r}
milo.res$method <- "glmm"
milo.res.fixed$method <- "glm"
milo_plot <- rbind.data.frame(milo.res[ ,8:9], milo.res.fixed[,7:8])

ggplot(milo_plot, aes(x = SpatialFDR, group_by = method))+ 
    #geom_freqpoly(bins = 50, aes(fill = method)) +
    geom_density(aes(fill = method), alpha=0.5) +
    theme_bw(base_size=16) +
    scale_fill_manual(values = c("#F4D1E9", "#8da0cb"), name="Model", labels = c("Fixed effects (GLM)", "Mixed effects (GLMM)")) +
    labs(x="Spatial FDR P value", y="Density") +
    theme(legend.position = "top", axis.text.x=element_text(colour="black"), axis.text.y=element_text(colour="black")) +
    scale_x_continuous(expand = c(0,0)) +
    scale_y_continuous(expand = c(0,0), limits = c(0, 8.75))

ggsave("fig3.tiff", path = "/Users/kluzer01/Desktop/figures/", height = 4, width = 7, device='tiff', dpi=700)
```


```{r}
conv.list <- model.list$Iterations
diff.df <- melt(do.call(cbind,
                        lapply(conv.list, function(X){
                            if(!is.null(ncol(X$Theta.Diff))){
                                x <- X$Theta.Diff[, 1]
                                names(x) <- rownames(X$Theta.Diff)
                            } else{
                               x <- X$Theta.Diff
                               names(x) <- c(colnames(X), paste(colnames(Z), c(1:length(levels(as.factor(sim.df$RE1)))), sep="_"))
                            }
                            x})))
diff.df$Var2 <- rep(1:(max(as.numeric(names(model.list$Iterations)))), each = 12)


theta.df <- melt(do.call(cbind,
                        lapply(conv.list, function(X){
                            if(!is.null(ncol(X$Theta))){
                                x <- X$Theta[, 1]
                                names(x) <- rownames(X$Theta)
                            } else{
                                x <- x$Theta
                                names(x) <- c(colnames(X), paste(colnames(Z), c(1:length(levels(as.factor(sim.df$RE1)))), sep="_"))
                            }
                            x
                            })))
theta.df$Var2 <- rep(1:(max(as.numeric(names(model.list$Iterations)))), each = 12)

variance.diff.df <- melt(do.call(cbind,
                        lapply(conv.list, function(X){
                            if(!is.null(ncol(X$Sigma.Diff))){
                                x <- X$Sigma.Diff[, 1]
                            } else{
                                x <- X$Sigma.Diff
                            }
                            x
                            })))

variance.diff.df$Var2 <- rep(1:(max(as.numeric(names(model.list$Iterations)))), each = 1)

variance.df <- melt(do.call(cbind,
                        lapply(conv.list, function(X){
                            if(!is.null(ncol(X$Sigma))){
                                x <- X$Sigma[, 1]
                            } else{
                                x <- X$Sigma
                            }
                            x
                            })))
variance.df$Var2 <- rep(1:(max(as.numeric(names(model.list$Iterations)))), each = 1)

ggplot(diff.df, aes(x=Var2, y=abs(value), colour=Var1)) +
    # geom_point() +
    geom_hline(yintercept=theta.conv, lty=2, col='red') +
    geom_line() +
    theme_cowplot() +
    scale_colour_ptol() +
    # scale_x_continuous(breaks=c(0:100)) +
    labs(x="Iteration", y=expression(theta[0] - theta["t"])) +
    facet_wrap(~Var1, scales="free_y") +
    #scale_y_log10() +
    # expand_limits(y=c(1e-8)) +
    NULL
```


